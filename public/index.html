<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Status Monitor</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .status-card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .status-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        .status-dot.online {
            background: #10b981;
        }
        
        .status-dot.offline {
            background: #ef4444;
            animation: none;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .status-text {
            font-size: 1.5em;
            font-weight: bold;
        }
        
        .status-text.online {
            color: #10b981;
        }
        
        .status-text.offline {
            color: #ef4444;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .info-item {
            padding: 15px;
            background: #f3f4f6;
            border-radius: 10px;
        }
        
        .info-label {
            font-size: 0.9em;
            color: #6b7280;
            margin-bottom: 5px;
        }
        
        .info-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #1f2937;
        }
        
        .history-card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
        }
        
        .history-card h2 {
            margin-bottom: 20px;
            color: #1f2937;
        }
        
        .history-item {
            padding: 15px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .history-item:last-child {
            border-bottom: none;
        }
        
        .history-time {
            color: #6b7280;
            font-size: 0.9em;
        }
        
        .history-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .history-status.online {
            background: #d1fae5;
            color: #065f46;
        }
        
        .history-status.offline {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #6b7280;
        }
        
        .error {
            background: #fee2e2;
            color: #991b1b;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .chart-container h2 {
            margin-bottom: 20px;
            color: #1f2937;
        }
        
        .chart-wrapper {
            position: relative;
            height: 300px;
            min-height: 300px;
        }
        
        #statusChart {
            max-height: 300px;
        }
        
        .offline-log {
            background: #fef3c7;
            border-left: 4px solid #f59e0b;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        
        .offline-log strong {
            color: #92400e;
        }
        
        .history-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f3f4f6;
            border-radius: 10px;
        }
        
        .history-controls label {
            font-weight: 600;
            color: #1f2937;
            min-width: 120px;
        }
        
        .slider-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider {
            flex: 1;
            height: 8px;
            border-radius: 5px;
            background: #d1d5db;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .slider-value {
            min-width: 80px;
            text-align: center;
            font-weight: bold;
            color: #667eea;
            font-size: 0.9em;
        }
        
        #history-container {
            height: 600px !important;
            max-height: 600px !important;
            overflow-y: auto !important;
            overflow-x: hidden;
            scroll-behavior: smooth;
            flex-shrink: 0;
        }
        
        #history-container::-webkit-scrollbar {
            width: 8px;
        }
        
        #history-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        
        #history-container::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
        }
        
        #history-container::-webkit-scrollbar-thumb:hover {
            background: #5568d3;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üì° ESP32 Status Monitor</h1>
            <p>Real-time device monitoring dashboard</p>
        </div>
        
        <div id="error-container"></div>
        
        <div class="status-card">
            <div class="status-indicator">
                <div id="status-dot" class="status-dot offline"></div>
                <div id="status-text" class="status-text offline">OFFLINE</div>
            </div>
            
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Last Seen</div>
                    <div id="last-seen" class="info-value">Never</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Time Since Last Update</div>
                    <div id="time-since" class="info-value">--</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Uptime</div>
                    <div id="uptime" class="info-value">--</div>
                </div>
                <div class="info-item">
                    <div class="info-label">IP Address</div>
                    <div id="ip-address" class="info-value">--</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Signal Strength</div>
                    <div id="rssi" class="info-value">--</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Free Memory</div>
                    <div id="free-heap" class="info-value">--</div>
                </div>
            </div>
        </div>
        
        <div class="chart-container">
            <h2>üìä Online/Offline Timeline (Last 24 Hours)</h2>
            <div class="chart-wrapper">
                <canvas id="statusChart"></canvas>
            </div>
        </div>
        
        <div class="status-card" id="offline-events-card" style="display: none;">
            <h2 style="margin-bottom: 15px; color: #1f2937;">‚ö†Ô∏è Offline Events</h2>
            <div id="offline-events-container"></div>
        </div>
        
        <div class="history-card">
            <h2>Recent Activity</h2>
            <div class="history-controls">
                <label>Scroll Timeline:</label>
                <div class="slider-container">
                    <input type="range" id="history-slider" class="slider" min="0" max="100" value="100" step="1">
                    <span class="slider-value" id="slider-value">Latest</span>
                </div>
            </div>
            <div id="history-container">
                <div class="loading">Loading history...</div>
            </div>
        </div>
    </div>
    
    <script>
        let updateInterval;
        let statusChart;
        let fullHistory = []; // Store full history for slider
        let isScrolling = false; // Flag to prevent scroll loop
        
        // Initialize chart
        function initChart() {
            const ctx = document.getElementById('statusChart').getContext('2d');
            statusChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Status',
                        data: [],
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 4,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            min: -0.1,
                            max: 1.1,
                            ticks: {
                                stepSize: 1,
                                callback: function(value) {
                                    if (value === 1) return 'Online';
                                    if (value === 0) return 'Offline';
                                    return '';
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        },
                        x: {
                            ticks: {
                                maxTicksLimit: 24,
                                autoSkip: true
                            },
                            grid: {
                                display: false
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.parsed.y === 1 ? 'Online' : 'Offline';
                                }
                            }
                        }
                    }
                }
            });
        }
        
        async function fetchStatus() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();
                
                updateUI(data);
                document.getElementById('error-container').innerHTML = '';
            } catch (error) {
                console.error('Error fetching status:', error);
                document.getElementById('error-container').innerHTML = 
                    '<div class="error">Error connecting to server. Make sure your ESP32 is sending updates.</div>';
            }
        }
        
        function updateUI(data) {
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');
            
            if (data.status === 'online') {
                statusDot.className = 'status-dot online';
                statusText.className = 'status-text online';
                statusText.textContent = 'ONLINE';
            } else {
                statusDot.className = 'status-dot offline';
                statusText.className = 'status-text offline';
                statusText.textContent = 'OFFLINE';
            }
            
            // Format time in local timezone - ensure proper conversion
            let lastSeenDate = null;
            if (data.last_seen) {
                // Ensure proper timezone conversion
                lastSeenDate = new Date(data.last_seen + (data.last_seen.includes('Z') ? '' : 'Z'));
            }
            document.getElementById('last-seen').textContent = 
                lastSeenDate ? lastSeenDate.toLocaleString(undefined, {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: true
                }) : 'Never';
            
            document.getElementById('time-since').textContent = 
                data.minutes_since_last_seen !== undefined 
                    ? `${data.minutes_since_last_seen.toFixed(1)} minutes ago`
                    : '--';
            
            if (data.latest_update) {
                document.getElementById('uptime').textContent = 
                    data.latest_update.uptime_formatted || '--';
                document.getElementById('ip-address').textContent = 
                    data.latest_update.ip_address || '--';
                document.getElementById('rssi').textContent = 
                    data.latest_update.rssi ? `${data.latest_update.rssi} dBm` : '--';
                document.getElementById('free-heap').textContent = 
                    data.latest_update.free_heap ? `${(data.latest_update.free_heap / 1024).toFixed(1)} KB` : '--';
            }
        }
        
        function renderHistory() {
            const container = document.getElementById('history-container');
            const slider = document.getElementById('history-slider');
            const sliderValue = document.getElementById('slider-value');
            
            if (fullHistory.length === 0) {
                container.innerHTML = '<div class="loading">No history available yet</div>';
                return;
            }
            
            // Display ALL history entries (reversed so most recent is at top)
            const historyToShow = [...fullHistory].reverse();
            container.innerHTML = historyToShow.map(item => {
                // Fix timezone - ensure proper conversion to local time
                const serverTime = item.server_timestamp;
                const date = new Date(serverTime + (serverTime.includes('Z') ? '' : 'Z'));
                const localTime = date.toLocaleString(undefined, {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: true
                });
                const isBoot = item.is_boot === 1;
                const isOfflineMarker = item.is_offline_marker;
                return `
                    <div class="history-item" data-index="${historyToShow.indexOf(item)}">
                        <div>
                            <div class="history-time">${localTime}</div>
                            <div>${isOfflineMarker ? '‚ö†Ô∏è Device Offline' : isBoot ? 'üîÑ Device Booted' : 'üì° Status Update'} | Uptime: ${item.uptime_formatted || 'N/A'}</div>
                        </div>
                        <div class="history-status ${item.status || 'offline'}">${(item.status || 'offline').toUpperCase()}</div>
                    </div>
                `;
            }).join('');
            
            // Update slider position to scroll to the selected position
            updateScrollPosition();
        }
        
        function updateScrollPosition() {
            const container = document.getElementById('history-container');
            const slider = document.getElementById('history-slider');
            const sliderValue = document.getElementById('slider-value');
            
            if (!container || !slider || fullHistory.length === 0) return;
            
            const sliderPercent = parseInt(slider.value);
            
            // Calculate scroll position based on slider value
            // 0% = oldest (bottom), 100% = newest (top)
            const maxScroll = container.scrollHeight - container.clientHeight;
            const scrollPosition = maxScroll * (1 - sliderPercent / 100);
            
            isScrolling = true;
            container.scrollTop = scrollPosition;
            setTimeout(() => { isScrolling = false; }, 100);
            
            // Update label
            if (sliderPercent === 100) {
                sliderValue.textContent = 'Latest';
            } else if (sliderPercent === 0) {
                sliderValue.textContent = 'Oldest';
            } else {
                // Show approximate time position
                const totalEntries = fullHistory.length;
                const entryIndex = Math.floor((sliderPercent / 100) * totalEntries);
                const entry = fullHistory[fullHistory.length - 1 - entryIndex];
                if (entry && entry.server_timestamp) {
                    const date = new Date(entry.server_timestamp + (entry.server_timestamp.includes('Z') ? '' : 'Z'));
                    const timeStr = date.toLocaleTimeString(undefined, {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: true
                    });
                    sliderValue.textContent = timeStr;
                } else {
                    sliderValue.textContent = `${sliderPercent}%`;
                }
            }
        }
        
        async function fetchHistory() {
            try {
                // Add cache-busting parameter to ensure fresh data
                const cacheBuster = new Date().getTime();
                const response = await fetch(`/api/history?limit=500&_=${cacheBuster}`);
                const history = await response.json();
                
                const container = document.getElementById('history-container');
                
                if (history.length === 0) {
                    container.innerHTML = '<div class="loading">No history available yet</div>';
                    if (statusChart) {
                        // Show empty chart
                        statusChart.data.labels = [];
                        statusChart.data.datasets[0].data = [];
                        statusChart.update();
                    }
                    return;
                }
                
                console.log('Fetched history:', history.length, 'items');
                
                // Log the most recent entry timestamp for debugging
                if (history.length > 0) {
                    const mostRecent = history[history.length - 1];
                    console.log('Most recent entry:', mostRecent.server_timestamp, 'Current time:', new Date().toISOString());
                }
                
                // Store full history for slider
                fullHistory = history;
                
                // Update chart with history data (await to ensure current status is fetched)
                updateChart(history).catch(err => console.error('Chart update error:', err));
                
                // Detect offline events
                detectOfflineEvents(history);
                
                // Display history (all entries)
                renderHistory();
                
                // Scroll to latest position after a short delay to ensure DOM is ready
                setTimeout(() => {
                    const container = document.getElementById('history-container');
                    if (container) {
                        // Only auto-scroll if slider is at 100% (Latest)
                        const slider = document.getElementById('history-slider');
                        if (slider && parseInt(slider.value) === 100) {
                            container.scrollTop = 0; // Most recent is at top after reverse()
                            updateScrollPosition();
                        }
                    }
                }, 100);
                    // Fix timezone - ensure proper conversion to local time
                    const serverTime = item.server_timestamp;
                    const date = new Date(serverTime + (serverTime.includes('Z') ? '' : 'Z'));
                    const localTime = date.toLocaleString(undefined, {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: true
                    });
                    const isBoot = item.is_boot === 1;
                    const isOfflineMarker = item.is_offline_marker;
                    return `
                        <div class="history-item">
                            <div>
                                <div class="history-time">${localTime}</div>
                                <div>${isOfflineMarker ? '‚ö†Ô∏è Device Offline' : isBoot ? 'üîÑ Device Booted' : 'üì° Status Update'} | Uptime: ${item.uptime_formatted || 'N/A'}</div>
                            </div>
                            <div class="history-status ${item.status || 'offline'}">${(item.status || 'offline').toUpperCase()}</div>
                        </div>
                    `;
                }).join('');
            } catch (error) {
                console.error('Error fetching history:', error);
            }
        }
        
        async function updateChart(history) {
            if (!statusChart) {
                console.error('Chart not initialized');
                return;
            }
            
            try {
                if (!history || history.length === 0) {
                    console.log('No history data for chart');
                    return;
                }
                
                // Get current status
                let currentStatusIsOffline = false;
                try {
                    const statusResponse = await fetch('/api/status');
                    const statusData = await statusResponse.json();
                    currentStatusIsOffline = statusData.status === 'offline';
                } catch (e) {
                    console.error('Error fetching current status:', e);
                }
                
                // Get last 24 hours of data
                const now = new Date();
                const oneDayAgo = new Date(now - 24 * 60 * 60 * 1000);
                
                // Filter and process data
                const recentHistory = history.filter(item => {
                    if (!item.server_timestamp) return false;
                    try {
                        const itemTime = item.server_timestamp.includes('Z') ? item.server_timestamp : item.server_timestamp + 'Z';
                        const itemDate = new Date(itemTime);
                        return !isNaN(itemDate.getTime()) && itemDate >= oneDayAgo;
                    } catch (e) {
                        return false;
                    }
                });
                
                console.log('Recent history for chart:', recentHistory.length, 'items');
                
                // Create time buckets - use actual data points, not fixed intervals
                // Sort history by time
                const sortedHistory = [...recentHistory].sort((a, b) => {
                    const timeA = (a.server_timestamp.includes('Z') ? a.server_timestamp : a.server_timestamp + 'Z');
                    const timeB = (b.server_timestamp.includes('Z') ? b.server_timestamp : b.server_timestamp + 'Z');
                    return new Date(timeA) - new Date(timeB);
                });
                
                // Create data points: for each status update, determine if online (1) or offline (0)
                const labels = [];
                const data = [];
                const colors = [];
                
                // Process each history item
                sortedHistory.forEach((item, index) => {
                    if (!item.server_timestamp) return;
                    
                    try {
                        const itemTime = item.server_timestamp.includes('Z') ? item.server_timestamp : item.server_timestamp + 'Z';
                        const itemDate = new Date(itemTime);
                        
                        if (isNaN(itemDate.getTime())) return;
                        
                        // Create label
                        const timeLabel = itemDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        labels.push(timeLabel);
                        
                        // Determine status: 1 = online, 0 = offline
                        let status = 1; // Default to online
                        if (item.is_offline_marker || item.status === 'offline') {
                            status = 0; // Offline
                        }
                        
                        data.push(status);
                        
                        // Set color
                        if (status === 1) {
                            colors.push('rgba(16, 185, 129, 0.4)'); // Green
                        } else {
                            colors.push('rgba(239, 68, 68, 0.4)'); // Red
                        }
                    } catch (e) {
                        console.error('Error processing history item:', e);
                    }
                });
                
                // Add current status if not in history
                if (labels.length === 0 || (currentStatusIsOffline && data[data.length - 1] !== 0) || (!currentStatusIsOffline && data[data.length - 1] !== 1)) {
                    labels.push(now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
                    data.push(currentStatusIsOffline ? 0 : 1);
                    colors.push(currentStatusIsOffline ? 'rgba(239, 68, 68, 0.4)' : 'rgba(16, 185, 129, 0.4)');
                }
                
                // Limit to last 100 points for performance
                if (labels.length > 100) {
                    const start = labels.length - 100;
                    labels.splice(0, start);
                    data.splice(0, start);
                    colors.splice(0, start);
                }
                
                // Update chart
                if (labels.length > 0 && data.length > 0) {
                    statusChart.data.labels = labels;
                    statusChart.data.datasets[0].data = data;
                    statusChart.data.datasets[0].backgroundColor = colors;
                    statusChart.data.datasets[0].borderColor = '#10b981';
                    statusChart.data.datasets[0].pointRadius = 3;
                    statusChart.data.datasets[0].pointHoverRadius = 5;
                    statusChart.update();
                    console.log('Chart updated:', data.length, 'points | Online (1):', data.filter(d => d === 1).length, '| Offline (0):', data.filter(d => d === 0).length);
                } else {
                    console.log('No data points to display in chart');
                }
            } catch (error) {
                console.error('Error updating chart:', error);
            }
        }
        
        async function detectOfflineEvents(history) {
            const offlineEvents = [];
            
            // Sort by timestamp - fix timezone conversion
            const sortedHistory = [...history].sort((a, b) => {
                const timeA = a.server_timestamp + (a.server_timestamp.includes('Z') ? '' : 'Z');
                const timeB = b.server_timestamp + (b.server_timestamp.includes('Z') ? '' : 'Z');
                return new Date(timeA) - new Date(timeB);
            });
            
            if (sortedHistory.length === 0) {
                displayOfflineEvents([]);
                return;
            }
            
            let offlineStart = null;
            let lastStatus = null;
            
            // First pass: detect offline markers and status changes
            for (let i = 0; i < sortedHistory.length; i++) {
                const item = sortedHistory[i];
                const itemTime = item.server_timestamp + (item.server_timestamp.includes('Z') ? '' : 'Z');
                const itemDate = new Date(itemTime);
                const isOfflineMarker = item.is_offline_marker === true;
                const isOffline = isOfflineMarker || item.status === 'offline';
                const isOnline = !isOffline && (item.status === 'online' || (!item.is_offline_marker && item.status !== 'offline'));
                
                // Detect transition from online to offline
                if (isOffline && (lastStatus === 'online' || lastStatus === null)) {
                    offlineStart = itemDate;
                }
                
                // Detect transition from offline to online
                if (isOnline && offlineStart !== null) {
                    const duration = (itemDate - offlineStart) / 1000 / 60;
                    if (duration > 0.5) { // Only record if offline for at least 30 seconds
                        offlineEvents.push({
                            start: offlineStart,
                            end: itemDate,
                            duration: duration
                        });
                    }
                    offlineStart = null;
                }
                
                lastStatus = isOffline ? 'offline' : 'online';
            }
            
            // Second pass: detect gaps between consecutive entries (fallback for missed transitions)
            for (let i = 0; i < sortedHistory.length - 1; i++) {
                const currentTime = sortedHistory[i].server_timestamp + (sortedHistory[i].server_timestamp.includes('Z') ? '' : 'Z');
                const nextTime = sortedHistory[i + 1].server_timestamp + (sortedHistory[i + 1].server_timestamp.includes('Z') ? '' : 'Z');
                const current = new Date(currentTime);
                const next = new Date(nextTime);
                const gapMinutes = (next - current) / 1000 / 60;
                
                // If gap is more than 1 minute, it's likely an offline period
                if (gapMinutes > 1) {
                    // Check if we already have an event covering this period
                    const alreadyCovered = offlineEvents.some(event => {
                        return (current >= event.start && current <= event.end) ||
                               (next >= event.start && next <= event.end);
                    });
                    
                    if (!alreadyCovered) {
                        offlineEvents.push({
                            start: current,
                            end: next,
                            duration: gapMinutes
                        });
                    }
                }
            }
            
            // Check if device is currently offline (no end time yet)
            try {
                const statusResponse = await fetch('/api/status');
                const currentStatus = await statusResponse.json();
                
                if (currentStatus.status === 'offline') {
                    // Find the last known offline start time
                    const lastOfflineEntry = sortedHistory
                        .filter(item => item.is_offline_marker || item.status === 'offline')
                        .sort((a, b) => {
                            const timeA = a.server_timestamp + (a.server_timestamp.includes('Z') ? '' : 'Z');
                            const timeB = b.server_timestamp + (b.server_timestamp.includes('Z') ? '' : 'Z');
                            return new Date(timeB) - new Date(timeA);
                        })[0];
                    
                    if (lastOfflineEntry) {
                        const lastOfflineTime = lastOfflineEntry.server_timestamp + (lastOfflineEntry.server_timestamp.includes('Z') ? '' : 'Z');
                        const lastOfflineDate = new Date(lastOfflineTime);
                        const now = new Date();
                        const duration = (now - lastOfflineDate) / 1000 / 60;
                        
                        // Check if this ongoing offline event is already recorded
                        const ongoingExists = offlineEvents.some(event => 
                            event.ongoing === true || 
                            (Math.abs(event.start - lastOfflineDate) < 60000 && event.end >= now)
                        );
                        
                        if (!ongoingExists && duration > 0.5) {
                            offlineEvents.push({
                                start: lastOfflineDate,
                                end: now,
                                duration: duration,
                                ongoing: true
                            });
                        }
                    }
                }
            } catch (err) {
                console.error('Error fetching current status for offline detection:', err);
            }
            
            // Sort events by start time (most recent first)
            offlineEvents.sort((a, b) => b.start - a.start);
            
            // Remove duplicates (events that overlap significantly)
            const uniqueEvents = [];
            for (const event of offlineEvents) {
                const isDuplicate = uniqueEvents.some(existing => {
                    const timeDiff = Math.abs(existing.start - event.start);
                    return timeDiff < 60000; // Within 1 minute
                });
                if (!isDuplicate) {
                    uniqueEvents.push(event);
                }
            }
            
            // Display offline events
            displayOfflineEvents(uniqueEvents);
        }
        
        function displayOfflineEvents(offlineEvents) {
            
            const container = document.getElementById('offline-events-container');
            const card = document.getElementById('offline-events-card');
            
            if (offlineEvents.length > 0) {
                card.style.display = 'block';
                container.innerHTML = offlineEvents.slice(0, 10).map(event => {
                    // Fix timezone for offline events
                    const startTime = event.start.toLocaleString(undefined, {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: true
                    });
                    const endTime = event.end.toLocaleString(undefined, {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: true
                    });
                    const durationText = event.ongoing 
                        ? `${Math.round(event.duration)} minutes (ongoing)`
                        : `${Math.round(event.duration)} minutes`;
                    return `
                        <div class="offline-log">
                            <strong>‚ö†Ô∏è Device went offline</strong><br>
                            From: ${startTime}<br>
                            To: ${endTime}<br>
                            Duration: ${durationText}
                        </div>
                    `;
                }).join('');
            } else {
                card.style.display = 'none';
            }
        }
        
        // Wait for page to fully load before initializing chart
        window.addEventListener('load', () => {
            // Initialize chart
            try {
                initChart();
                console.log('Chart initialized');
            } catch (error) {
                console.error('Error initializing chart:', error);
            }
            
            // Initial load
            fetchStatus();
            fetchHistory();
            
            // Slider event listener for scrolling
            const slider = document.getElementById('history-slider');
            if (slider) {
                slider.addEventListener('input', () => {
                    updateScrollPosition();
                });
            }
            
            // Also update slider value when container scrolls (sync slider display)
            const container = document.getElementById('history-container');
            if (container) {
                container.addEventListener('scroll', () => {
                    if (!isScrolling && container.scrollHeight > container.clientHeight) {
                        const scrollPercent = (container.scrollTop / (container.scrollHeight - container.clientHeight)) * 100;
                        const sliderPercent = 100 - scrollPercent; // Invert: top = 100%, bottom = 0%
                        slider.value = Math.round(sliderPercent);
                        // Just update the label, don't trigger scroll
                        const sliderValue = document.getElementById('slider-value');
                        if (sliderPercent === 100) {
                            sliderValue.textContent = 'Latest';
                        } else if (sliderPercent === 0) {
                            sliderValue.textContent = 'Oldest';
                        } else {
                            sliderValue.textContent = `${Math.round(sliderPercent)}%`;
                        }
                    }
                });
            }
            
            // Update every 5 seconds
            updateInterval = setInterval(() => {
                fetchStatus();
                fetchHistory();
            }, 5000);
        });
    </script>
</body>
</html>

